Potential Bugs:
- Popup Message Targeting: In the `chrome.webRequest.onCompleted` listener, `chrome.runtime.sendMessage` is called with `{ action: "updatePopupDomains", tabId: tabId, domains: domains }`. The `tabId` here is the ID of the tab that completed the web request. If this tab is not the currently active tab where the user has the popup open, the message might be ignored by the popup or could potentially lead to unexpected behavior if the popup isn't strictly filtering messages for its own active tab ID. The `chrome.tabs.query { active: true, currentWindow: true }` call gets the `activeTab`, but this information isn't used to gate or target the `sendMessage` call specifically to the popup associated with `activeTab.id` if it differs from the event's `tabId`.
- Stale AI Model List: The `fetchAndStoreModels` function is called only once when the background script starts. If API keys (for Gemini or Groq) are added or updated via the options page *after* the extension has started, the list of available AI models will not be refreshed until the extension is reloaded (e.g., browser restart, manual extension reload). This means users might not see newly available models or be able to use a newly added API key without a reload.
- `activeTab` can be undefined: In `chrome.tabs.query { active: true, currentWindow: true }, (tabs) -> activeTab = tabs[0]`, if there is no active tab in the current window (e.g., if the query runs in a context where a window exists but has no active tab, or if the window is closing), `tabs[0]` could be undefined. Accessing `activeTab.id` later would throw an error. The current code doesn't immediately break here, but it's a fragile point as `sendMessage` proceeds regardless.
